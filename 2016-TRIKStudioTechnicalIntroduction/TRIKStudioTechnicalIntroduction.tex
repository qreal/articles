\documentclass[a5paper]{article}
\usepackage[a5paper, top=17mm, bottom=17mm, left=17mm, right=17mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{cmap}

\usepackage{polyglossia}
\setdefaultlanguage[babelshorthands=true]{russian}

\usepackage{fontspec}
\setmainfont{FreeSerif}
\newfontfamily{\russianfonttt}{FreeSerif}

\usepackage{amsmath}
\usepackage{amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{array}
\usepackage{hhline}
\usepackage{cite}

\usepackage[xetex,linktocpage=true,plainpages=false,pdfpagelabels=false]{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=1, pdfauthor=, pdfsubject=, pdfkeywords=}

\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{multirow}
\usepackage{subfig}
\usepackage{tabularx}
\usepackage{footnote}
\makesavenoteenv{tabular}
\makesavenoteenv{table}

\newcommand*\rot{\rotatebox{-90}}

\sloppy
\pagestyle{plain}

\title{Техническое введение в TRIK Studio --- визуальную среду программирования роботов}

\author{
	Д.А. Мордвинов \\
	Санкт-Петербургский государственный университет\\
	Кафедра системного программирования\\
	Email: mordvinov.dmitry@gmail.com
}

\date{}

\begin{document}

\maketitle
\thispagestyle{empty}

\begin{quote}
\small\noindent Здесь будет абстракт
\end{quote}

\section*{Введение}
\label{chapter:introduction}

Современное состояние школьного образования в области информатики можно назвать миром сбывшихся пророчеств Сеймура Пейперта. Еще в 1967 им был предложен исполнитель <<черепашка Logo>>, до сих пор широко используемый для обучения школьников программированию. Чуть менее известно, что наряду с виртуальным исполнителем, Пейперт в своих экспериментах использовал механического робота-черепашку, управляемого с компьютера~\cite{papert1980mindstorms}, что делало процесс обучения программированию более увлекательным. Сегодня идеи Пейперта получили широкое распространение: практически повсеместно происходит массовое внедрение реальных исполнителей в школы (к примеру, в России с 2015 года робототехника входит в программу обязательного школьного образования как часть предмета <<технология>>~\cite{черёмухин2014внедрение}). При этом чаще всего используются робототехнические конструкторы, такие как Lego Mindstorms NXT и Lego Mindstorms EV3%
\footnote{Домашняя страница LEGO Mindstorms, URL: http://www.lego.com/en-us/mindstorms (дата обращения: 27.04.2016г)}, 
ТРИК\footnote{Домашняя страница конструктора ТРИК, URL: http://www.trikset.com/ (дата обращения: 27.04.2016г)} и т.д. 

Задача программирования робота, собранного из конструктора, сложнее, чем виртуальной <<черепашку>>: программы должны быть написаны в терминах мощностей моторов и значений с датчиков вместо конкретных перемещений и поворотов. Поэтому при внедрении таких конструкторов в учебный процесс большое внимание уделяется средствам их программирования. При этом довольно популярными являются визуальные языки, поскольку они нагляднее текстовых и проще в изучении. Программирование в таких средах осуществляется в основном перетаскиванием графических примитивов с помощью компьютерной мыши, иногда это дает возможность программировать роботов даже детям, которые еще не умеют читать. 

Популярность визуальных языков в образовательной робототехнике подчеркивается количеством сред программирования учебных роботов на таких языках. К самым известным отнесем Robolab~\cite{erwin2000lego}, NXT-G~\cite{kelly2010lego} и EV3-G~\cite{valk2014lego}, Scratch~\cite{resnick2009scratch} и Scratch-подобные среды (S4A~\cite{s4a}, mBlock~\cite{mblock}, Enchanting~\cite{enchanting}, ScrathDuino~\cite{scratchduino}, Blockly~\cite{blockly} и App Inventor~\cite{wolber2011app}, 12Blocks~\cite{12blocks}, Open Roberta~\cite{jost2014graphical}), Ardublock~\cite{ardublock}), среды программирования менее популярных конструкторов и роботов, такие, как Robo PRO~\cite{chang2006incorporating} для конструктора fischertechnik или Scribbler Program Maker для роботов Scribbler), а также среды программирования для дошкольников и учеников начальных школ Lego WeDo Software~\cite{mayerova2012pilot}, Create~\cite{cross2013visual}, Wonder~\cite{wonder}. В наши дни научная область образовательной робототехники представляет большой интерес в мире, о чем говорит тот факт, что в 2010-х годах практически каждый ведущий университет мира занялся разработкой собственных решений. К примеру, в апреле 2016 года Гарвардский Университет представил платформу Root~\cite{root}, Университет Карнеги--Меллон занимается разработкой и продвижением проекта Arts\&Bots~\cite{cross2013visual}, Массачусетский технологический институт внес свой вклад созданием системы Scratch~\cite{resnick2009scratch}, и данный список на этом не иссякает. Подробный русскоязычный обзор всех вышеупомянутых сред можно найти в работе~\cite{mordvinov2016NONPUBLISHED}, в которой делается вывод о том, что несмотря на разнообразие всех инструментов в данной области, ни один из них не может удовлетворить всем требованиям, которые ставятся теми или иными образовательными учреждениями. Подавляющее большинство таких сред реализуют только наиболее общую и необходимую функциональность (редактор визуальных диаграмм и возможность исполнить их на роботе с отладкой на компьютере или в автономном режиме), однако в них отсутствуют более специализированные средства обучения программированию, например, возможность генерации читаемого кода по визуальной диаграмме для облегчения перехода с визуальных языков на текстовые, возможность отладки программы на виртуальном симуляторе робота перед исполнением на реальном устройстве или встроенные средства проверки корректности выполнения задания, что автоматизировало бы часть обязанностей преподавателя. В случае, если такие возможности присутствуют в системе, то не все сразу, и все такие среды проприетарны и не бесплатны: их пользователи могут попасть в ситуацию <<vendor lock-in>>, не говоря уже о том, что многие учебные заведения не могут позволить себе покупку дорогостоящих лицензий. 

Практически все вышеупомянутые языки реализуют модель вычисления с передачей управления (\textit{control flow}). Такая модель легче воспринимается людьми, поэтому ее разумнее использовать в образовательных целях. Тем не менее, модель потока управления не самая удачная для программирования роботов. Дело в том, что роботы по своей природе реактивны: программа управления роботом представляет собой преобразование сигналов с датчиков в импульсы на приводы. Реактивные модели хорошо описываются так называемыми \textit{языками программирования потоков данных} (\textit{dataflow languages})~\cite{johnston2004advances}, в которых программа представляется множеством <<черных ящиков>>, соединенных каналами данных. Каждый такой <<ящик>> (далее, \textit{блок}) имеет фиксированный набор входов и выходов, его работа состоит в преобразовании данных на входе в данные на выходе (далее данные, посылаемые по каналу, будем называть \textit{токенами}). К примеру, каждый датчик робота в такой схеме описывается всего одним блоком, который отправляет в выходные каналы токены значений с датчика. При этом многие исследователи отмечают удобство визуальных потоковых языков по сравнению с текстовыми (которые также известны как \textit{реактивные})~\cite{johnston2004advances}, в частности, из-за наглядной визуализации самих потоков данных.

Идея использования потоковых языков программирования в робототехнике не нова, она реализована практически в каждом инструменте для визуального программирования промышленных и лабораторных систем автоматизации. К таким системам отнесем LabVIEW от компании National Instruments~\cite{kodosky1991visual}, систему Simulink~\cite{dabney2004mastering}, а также среду визуального программирования роботов Microsoft Robotics Developer Studio~\cite{jackson2007microsoft}). Все упомянутые системы хорошо решают задачу автоматизации, имеют мощные инструментарии (например, Microsoft Robotics Developer Studio используется на серверах в широко известной социальной сети MySpace~\cite{scherotter2009ccr}), однако весьма сложны в изучении и даже громоздки, поэтому если и применяются в образовании, то гораздо чаще в университетском~\cite{stefanovic2011labview,yi2005labview}. В случае с LabVIEW, к примеру, школьные образовательные эксперименты были популярны в конце 1990-х годов~\cite{cyr1997low,portsmore1999robolab}, однако это привело к появлению адаптаций среды для целей образования (таких, как Robolab), в которых, в частности, модели потоков данных была предпочтена модель потока управления. Таким образом, образуется другая проблема --- <<разрыв>> между упрощенными учебными языками и <<серьезными>> потоковыми. Исследователи активно пытаются адаптировать потоковую модель для образовательной робототехники, к примеру, новозеландской исследовательской группой был предложен язык RuRu~\cite{diprose2011ruru}. Тем не менее, готовых сред программирования на визуальном потоковом языке, применяемых в образовании, все еще не существует.

Данная работа описывает новый инструмент программирования роботов TRIK Studio, являющийся попыткой решения вышеописанных проблем. Успешность их решения косвенно подтверждается практическими применениями: на данный момент TRIK Studio широко применяется в российском образовании (десятки школ и тематических кружков), известны применения в образовательном процессе европейских стран (Англии и Франции), отдельные пользователи есть на каждом обитаемом континенте мира. Описание будет дано с технической стороны, образовательные аспекты в данной статье обсуждаться практически не будут.

\section{Общее описание}
\label{chapter:commonDescription}

TRIK Studio --- среда визуального и текстового программирования популярных образовательных конструкторов роботов. В официальной версии имеется поддержка конструкторов Lego Mindstorms NXT, Lego Mindstorms EV3 и ТРИК. Каждый из этих конструкторов может быть запрограммирован на одном из двух визуальных языков --- более простом, построенном на модели потока управления, или более сложном, потоковом --- или на одном из нескольких текстовых: для Lego NXT доступны языки NXT OSEK C и русскоязычная версия C (для облегчения изучения текстовых языков), для ТРИК --- JavaScript, F\#~\cite{kirsanov2014robotics} или PascalABC.NET~\cite{doliner2014basics}, для Lego EV3 поддержан единственный официальный язык программирования стандартной прошивки, байткод виртуальной машины EV3. 

Визуальная диаграмма может быть исполнена в трех режимах: 
\begin{itemize}
    \item отладка на симуляторе,
    \item отладки на компьютере с посылкой пакетов на робота по одному из физических каналов (USB, Bluetooth, Wi-Fi, см. главу~\ref{chapter:communication}),
    \item режим генерации из визуальной диаграммы читаемого кода на одном из вышеупомянутых текстовом языке с последующим автономным исполнением его на роботе. 
\end{itemize}

В режиме отладки на симуляторе диаграмма интерпретируется на двумерной имитационной модели робота (см. раздел~\ref{chapter:2dModel}). Пользователь имеет возможность нарисовать двумерную модель мира из стенок, цветных элементов и разметки регионов. Опыт использования показал, что в редакторе модели мира можно создать большинство полей и полос препятствий, используемых на соревнованиях по спортивной робототехнике. Такая возможность, по отзывам пользователей, является очень удобной для первоначальной отладки программы перед каким-либо взаимодействием с роботом. Также наличие симулятора дает возможность обучения программированию и кибернетике в образовательных учреждениях, которые не имеют реальных роботов. Существует также экспериментальная поддержка отладки на трехмерном симуляторе роботов V-Rep~\cite{rohmer2013v}.

Отладка на компьютере с посылкой команд роботу (режим \textit{интерпретации} в терминах среды) удобна для отслеживания поведения программы на целевом устройстве в реальном времени. В режиме интерпретации можно отслеживать значения переменных в соответствующем окне среды (аналогичному, например, окну поддержки отладчика gdb в различных текстовых IDE), а также строить в реальном времени графики данных с датчиков.

Режим генерации кода позволяет перейти от визуального представления программы к текстовому. Тестовый код отображается во встроенном редакторе qscintilla\footnote{https://riverbankcomputing.com/software/qscintilla/intro (дата обращения: 14.05.2016)}, который обладает возможностью полноценного редактора кода (подсветка синтаксиса, автодополнение, подсветка скобок, отмена/повтор и т.д.). В дистрибутив среды входят все необходимые инструменты для построения и передачи программ на роботов (набор кросскомпиляторов, WinSCP и Putty и т.д.), поэтому процесс компиляции и взаимодействия с контроллерами роботов остается полностью <<прозрачным>> для пользователей. Многие из пользователей-новичков до определенного момента даже не догадываются, что при нажатии на кнопку автономного исполнения диаграммы превращаются в текстовое представления и компилируются в машинный код перед непосредственным запуском.

Общий пользовательский интерфейс среды представлен на рисунке~\ref{!!!}. На нем запечатлен момент отладки программы выезда робота из лабиринта на двумерном симуляторе.

% СКРИНШОТ ИНТЕРФЕЙСА С ЕЗДОЙ ИЗ ЛАБИРИНТА

В режиме двумерной симуляции доступна возможность автоматической проверки задач (см. раздел~\ref{chapter:constraintsChecker}). Программа проверки скриптуется на внутреннем легковесном событийном текстовом языке, файл с сохранением модели мира и программы проверки затем может распространяться как задача. На основе этой системы был запущен курс дистанционного обучения на платформе Stepic\footnote{https://stepic.org/s/7qe3xj4Z  (дата обращения: 14.05.2016)} с видео-лекциями по основам кибернетики, робототехники и использованию среды TRIK Studio, множеством небольших тестов и 20 задачами образовательной робототехники. Каждая задача может быть скачана, решена и проверена в TRIK Studio и сдана на сервер, где система проверки запустит решение на своих тестах (подобно формату решения задач на соревнованиях ACM ICPC).

Среда написана на языке C++ с инструментарием Qt\footnote{https://www.qt.io/ru/ (дата обращения: 14.05.2016)}, поэтому является кроссплатформенной (доступны установочные пакеты под Windows, Linux и Mac OS X). При этом, даже несмотря на то, что официальные драйвера для Lego NXT не доступны для Linux и Mac OS X x64, в TRIK Studio существует собственная их реализация на основе библиотеки libusb, подробнее см. главу~\ref{chapter:communication}. Среда полностью бесплатна, имеет открытый исходный код и распространяется под лицензией Apache License 2.0\footnote{http://www.apache.org/licenses/LICENSE-2.0  (дата обращения: 14.05.2016)}.

Описанные достоинства выгодно выделяют TRIK Studio на фоне всех аналогов. Фактически, среди упомянутых во введении систем, применяемых в школьном образовании, лишь среда 12Blocks обладает приближенной функциональностью, однако генерирует не читаемый код (для Lego NXT), не имеет средств проверки задач, является платной и не русифицирована. Основные недостатки TRIK Studio на данный момент --- это слабая методическая поддержка среды, ограничивающаяся лишь справкой на русском язык, набором примеров и упомянутым курсом дистанционного обучения. Существуют и другие, более мелкие особенности, о которых будет упомянуто в соответствующих разделах ниже.

Остаток статьи будет построен следующим образом. В главах~\ref{chapter:controlFlowLanguage} и~\ref{chapter:dataFlowLanguage} будут кратко описаны визуальные языки TRIK Studio и их интерпретаторы. Глава~\ref{chapter:commonArchitecture} дает общее представление об архитектуре среды. Дальнейшие главы будут посвящены конкретным подсистемам TRIK Studio. Общие сведения о реализации механизмов коммуникации с роботами даны в главе~\ref{chapter:communications}. Описания интерпретаторов визуальных языков в системе даны в главе~\ref{chapter:interpreters}. Наиболее интересные детали реализации генераторов в текстовые языки из диаграмм потока управления представлены в главе~\ref{chapter:generators}. В главе~\ref{chapter:2dModel} рассказывается об особенностях реализации подсистемы двумерного имитационного моделирования, далее, в главе~\ref{chapter:constraintsChecker} описан язык описания программ автоматической проверки заданий, исполняемых на этой подсистеме. Наконец, глава~\ref{chapter:conclusion} подводит итоги работы.

\section{Язык для начинающих}
\label{chapter:controlFlowLanguage}

Из всего множества языков, предлагаемых TRIK Studio, наиболее часто в образовательных целях используется упрощенный визуальный язык, основанный на модели потока управления (рис.~\ref{!!!}). Язык является графовым, т.е. программирование на нем ведется в терминах сущностей и связей. Для создания программы пользователь перетаскивает необходимые ему блоки на сцену редактора, правит их свойства и соединяет стрелками. Каждый блок выполняет какое-либо примитивное действие и передает управления по стрелкам.

Блоки в описываемом языке можно поделить на четыре группы. 
\begin{itemize}
    \item В первую группу включаются блоки основных алгоритмических конструкций, такие как блоки начала и конца исполнения программы или подпрограммы, ветвления, организации арифметического цикла, выбора (switch), распараллеливания и работы с параллельными задачами (их слияния и принудительного завершения), вызова подпрограммы, генерации случайных чисел и блок текстового программирования на встроенном языке.
    \item Вторая группа --- блоки работы с периферийными устройствами робота. Сюда включаются элементарные действия, не требующие ожидания. К примеру это блоки подачи импульсов на моторы, проигрывания звука, блоки работы с видео-зрением робота, синтезирования речи по заданной строке, управления счетчиками оборотов и лампочками на панелях контроллеров роботов, посылки сообщения на другого робота (часть поддержки мультиагентного взаимодействия), работы с файловой системой робота и т.д.
    \item Следующая группа включает в себя блоки, <<замораживающие>> исполнение текущего потока. Сюда входит блок ожидания заданное количества миллисекунд (аналог функции \texttt{msleep}), блоки ожидания желаемого значения с какого-либо датчика или пульта операторского управления роботом и блок ожидания сообщения с другого робота.
    \item Наконец, в четвертую группу входят блоки рисования графических примитивов на дисплее робота. К таким графическим примитивам относятся прямые линии, прямоугольники, эллипсы, дуги, текст, управление цветом и толщиной кисти рисования, цветом заливки фона, рисования картинок на экране (например, грустные и веселые смайлики), а также специальные блоки управления маркером для рисования в двумерном симуляторе траектории перемещения робота, что позволяет решать на среде класс задач, предлагаемых различными популярными двумерными исполнителями, такими, как <<Черепашка Logo>> или <<Чертежник>>.
\end{itemize}

% РИСУНОК С ПРОСТОЙ CONTROL-FLOW ПРОГРАММОЙ И ОПИСАНИЕМ ИСПОЛЬЗУЕМЫХ БЛОКОВ В ПОДПИСИ.

Свойства каждого блока могут быть отредактированы как на самой сцене редактора, так и на отдельной панели редактора свойств. Во всех свойствах блоков, где это уместно, имеется возможность задать вычислимое значение на встроенном в TRIK Studio текстовом языке --- статически типизируемом диалекте языка Lua\footnote{http://www.lua.ru/ (дата обращения: 14.05.2016)}. Модуль синтаксического разбора этого языка написан с применением библиотеки парсер-комбинаторов для языка C++ стандарта 2011 года, созданной также в рамках проекта TRIK Studio. Вывод типов узлов результирующего абстрактного синтаксического дерева осуществляется алгоритмом Хиндли-Милнера~\cite{damas1982principal}, в реализации которого сделаны упрощения, которые здесь из соображений краткости обсуждаться не будут.

Для реализации визуального языка был применен \textit{предметно-ориентированный подход} (\textit{DSM-approach})~\cite{koznov2008}. Редактор языка был создан при помощи DSM-платформы QReal~\cite{qrealMeta,kuzenkova2013qreal}. Метамодель языка была описана на визуальном метаредакторе DSM-платформы, далее по ней самой платформой был сгенерирован подключаемый модуль с редактором визуального языка. Результатом подключения такого модуля к ядру DSM-платформы является полноценная среда визуального программирования на языке, описанном метамоделью. Эта среда <<наследует>> все преимущества DSM-платформы, включая современный пользовательский интерфейс, поддержку рисования элементов жестами мышью~\cite{osechkina2010gestures,sechkina2012multistroke}, операции отмены-повтора в редакторе, возможности копирования-вставки групп элементов, изменения масштабов сцены редактора, различные способы рисования и отображения связей между элементами, панели-обозреватели моделей, поддержка особого режима работы на сенсорных-экранах и т.д. По отзывам пользователей, по эргономичности и современности визуальный редактор TRIK Studio превосходит многие аналоги, при этом время на создание первой версии визуального редактора заняло порядка трех человеко-дней. Все это говорит о разумности выбора DSM-платформы QReal в качестве базовой технологии, однако отметим, что во время выполнения описываемой работы в ядро DSM-платформы было внесено множество улучшений и исправлений.

\section{Язык для <<продвинутых>> пользователей}
\label{chapter:dataFlowLanguage}

Для пользователей, освоивших программирования на более простом языке, в среде существует возможность программирования на более сложном, но более удобном визуальном языке. Этот язык построен на модели потока данных. В отличие от предыдущего языка, где управление в диаграмме явно передается по стрелкам, блоки в данном языке исполняются параллельно, обмениваясь друг с другом токенами по каналам данных. К примеру, у программы на таком языке может быть сразу несколько точек входа (чаще всего, это датчики робота, которые посылают данные далее по цепочке их обработки), в то время как у каждой программы на языке с передачей управления есть лишь одна входная точка. Также как в предыдущем, в данном языке присутствуют блоки поддержки основных алгоритмических конструкций, блоки взаимодействия со всеми устройствами роботов, блоки рисования и т.д. Простой пример диаграммы, программирующей пропорциональный регулятор для следования вдоль стены на таком языке с противопоставлением к той же программе на языке с передачей управления представлен на рисунке~\ref{!!!}.

% Тут пример регулятора на DF и CF языках

Для упрощения изучения <<продвинутого>> языка в нем сохраняется концептуальная совместимость с моделью потока управления. Блоки здесь также могут быть выстроены в цепочку с явной передачей управления, для этого практически на всех блоках есть специальный порт активации, который игнорирует данные, приходящие на него и попросту передает управление блоку подобно тому, как это происходит в языке для начинающих. Поначалу программирование на нем может вестись сходно с тем, как оно велось на предыдущем языке, и лишь с приходом должного опыта пользователь будет выражать свои идеи меньшим количеством блоков. 

Выразительная сила языка позволяет описывать на нем широко известные в робототехническом сообществе подходы к построению сложных систем управления роботов, такие как категориальная архитектура, предложенная Родни Бруксом~\cite{brooks1986robust}, архитектура <<колония>> Джонатана Коннелла~\cite{connell1989colony}, схема поведенческой навигации Рональда Аркина~\cite{arkin1987motor}, или распределенная схема навигации DAMN~\cite{rosenblatt1997damn}. Доказательство этих фактов является скорее материалом для отдельной статьи и здесь приведено не будет (при желании читатель может убедиться в этом на собственном опыте). Некоторые общие соображения по этому поводу могут быть найдены в статье английских исследователей~\cite{simpson2009toward} и диссертации~\cite{banyasad2000visual}.

Следует отметить, что на момент написания статьи поддержка потокового языка в среде реализована в экспериментальном режиме и не входит в официальную версию, распространяемую между конечными пользователями. Исходный код его редактора и инструментальной поддержки находится в открытом доступе\footnote{https://github.com/ZiminGrigory/DFVPL (дата обращения: 14.05.2016)} и может быть собран вместе с исходным кодом TRIK Studio.

\section{Общая архитектура}
\label{chapter:commonArchitecture}

Цель данной главы --- структурирование информации предыдущих разделов в виде архитектурного описания: большинство описываемых здесь деталей в каком-либо виде уже были упомянуты выше. Все диаграммы, представленные в данной главе абстрагированы от множества деталей, которые, хоть и представляют интерес в контексте данной статьи, здесь представлены не будут из соображений лаконичности и понятности.

На рисунке~\ref{image:commonTSArch} представлена часть общей архитектура среды TRIK Studio. Как из него видно, система разбита на несколько <<слоев>> абстракции. Каждый из слоев содержит код, реализующий сложные элементы функциональности среды и при этом имеет свой строго определенный и задокументированный API. На самом низком уровне такими <<слоями>> являются библиотеки взаимодействия с реальными и виртуальными роботами. На основе такого взаимодействия строится иерархия устройств робота (датчиков, приводов, дисплеев, динамиков, пультов управления, кнопок на контроллере и т.д.), из которых, в свою очередь, составляется описание модели того или иного конструктора роботов. Описания модели роботов группируются в подключаемые к ядру TRIK Studio модули, они используются другими подсистемами TRIK Studio (интерпретаторами и генераторами, которые также представляют собой подключаемые к ядру TRIK Studio модули).

Ядро TRIK Studio, в свою очередь, является подключаемым к DSM-платформе QReal модулем\footnote{Таким образом, в проекте реализована двухуровневая схема подключаемых модулей, подобно тому, как это сделано в системе ReSharper от компании JetBrains: ReSharper может расширяться подключаемыми модулями, при этом сам является подключаемым к Visual Studio модулем}. Оно подстраивает интерфейс QReal под себя, добавляя к нему множество панелей и окон, таких, как окно двумерного симулятора, панели конфигурирования датчиков робота, просмотра их значений и построения графиков с них и т.д., подгружает все описания моделей роботов и отвечает за их рассылку всем необходимым подсистемам, предоставляет пользователю информацию о работе процесса генерации и интерпретации, и т.д. (полный список функций ядра слишком длинный и только усложнит восприятие). Наряду с ядром инструментальной поддержки TRIK Studio, к ядру QReal подключаются модули, описывающие редакторы визуальных языков, которые сгенерированы самой платформой QReal. Подробности про подсистемы более низкого уровня на рис.~\ref{image:commonTSArch} даны в главах ниже.

\begin{figure}[ht]
    \centering
    \includegraphics[width=4.5in]{TS_Common_Architecture.png}
    \caption{Общая архитектура системы}
    \label{image:commonTSArch}
\end{figure}

Как можно заметить, вся среда построена на принципе подключаемых модулей. Отметим, что такая идея позволила сделать более гибкой систему конфигурирования установки: пользователь может выбрать, какие компоненты ему интересны, а остальные отключить (например, если у него есть лишь конструктор Lego EV3, то ему не интересны модули поддержки конструкторов Lego NXT и TRIK, в таком случае к нему на компьютер даже не попадут файлы, эту поддержку предоставляющие). Более того, такой подход хорошо совместим с пакетной организацией систем установки программ на различные дистрибутивы Linux. Это хорошо и с архитектурной точки зрения, так как исчезает большинство зависимостей между компонентами --- ядро TRIK Studio, к примеру, <<минималистично>>, оно <<не знает>> обо всех возможностях среды и лишь предоставляет и реализует общие объекты и интерфейсы для каждого робототехнического конструктора. API каждого <<слоя>> абстракции  зафиксировано и задокументировано, это может позволить создавать модули поддержки новых языков и конструкторов в среде даже независимым разработчикам из сообщества проекта.

\section{Коммуникации с контроллерами роботов}
\label{chapter:communications}

Одна из важных подсистем TRIK Studio --- это модуль взаимодействия с контроллерами роботов по тому или иному физическому протоколу. На диаграмме компонентов~\ref{image:commonTSArch} это один из самых низких <<слоев>> абстракции среды. API модуля коммуникаций предоставляет следующие операции:

\begin{itemize}
    \item переключение текущего физического способа взаимодействия с целевым устройством (контроллеру робота) между Bluetooth, USB и Wi-Fi,
    \item указание адреса устройства в терминах физического протокола (это может быть номер COM-порта в случае с взаимодействием по Bluetooth, или IP-адрес или имя хоста в случае с взаимодействием по Wi-Fi),
    \item подключение-отключение к целевому устройству,
    \item посылка набора байтов на целевое устройство,
    \item события получения набора байтов с целевого устройства,
    \item события изменения статуса подключения (такие события вырабатываются, если связь с роботом установилась или разорвалась),
    \item события, оповещающие обо всех произошедших ошибках с локализованным их описанием.
\end{itemize}

Взаимодействие по USB происходит при помощи библиотеки libusb\footnote{http://libusb.org/ (дата обращения: 14.05.2016)}, для реализации обмена по Bluetooth используется библиотека QextSerialPort\footnote{https://github.com/qextserialport/ (дата обращения: 14.05.2016)}, взаимодействие по Wi-Fi происходит поверх протоколов TCP и UPD посредством библиотеки QtNetwork. Процесс общения с целевым устройствам происходит в отдельном потоке, чтобы не <<замораживать>> пользовательский интерфейс. Конкретные реализации механизмов коммуникации в подсистеме могут быть расширены и подменены другими подсистемами <<извне>>, это используется, например, для совместимости TRIK Studio со стандартным драйвером Lego NXT. Отметим, что взаимодействие через него --- это не единственный способ общения с контроллером NXT по USB в TRIK Studio, в среде реализован собственный, аналогичный драйвер Lego NXT, однако, в отличие от официального, работающий на всех поддерживаемых операционных системах через libusb.

\section{Интерпретаторы}
\label{chapter:interpreters}

Интерпретатор преобразует визуальную диаграмму в последовательность команд на целевом устройстве (рис.~\ref{image:interpretersTSArch}). При этом иерархия устройств в системе построена таким образом, что не делается различий, реальное ли это устройство или симулируемое (рис.~\ref{image:devicesTSArch}). Каждое устройство представляет собой класс C++, содержащий код взаимодействия с целевым механизмом. Реализации устройств какого-либо конструктора находятся в соответствующих библиотеках подключаемых модулей. Для общения по физическим каналам устройства используют подсистему физических коммуникаций (гл.~\ref{chapter:communications}), для передачи команд двумерному и трехмерному симуляторам --- API этих симуляторов.

\begin{figure}[ht]
    \centering
    \includegraphics[width=2.5in]{TS_Interpreter_Architecture.png}
    \caption{Общий принцип работы систем интерпретации}
    \label{image:interpretersTSArch}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=4.5in]{TS_Devices_Architecture.png}
    \caption{Часть иерархии устройств в системе}
    \label{image:devicesTSArch}
\end{figure}

Интерпретаторы, также как и вся система в целом, написан на языке C++ с использованием инструментария Qt. На вход подсистеме интерпретации поступает описание созданной пользователем диаграммы в некотором внутреннем представлении. В среде реализовано два интерпретатора: интерпретатор языка для начинающих с передачей управления и интерпретатор потокового языка.

Интерпретатор первого языка находит на диаграмме начальный блок, и далее трассирует поток управления диаграммы в том порядке, как он задан стрелками.  Текущий блок исполнения подсвечивается на визуальной диаграмме, чтобы пользователю был виден прогресс исполнения. Для каждого посещенного блока специальные фабрики интерпретатора создают объекты, которые реализуют его поведение. В общем случае, такой объект-реализация ищет среди готовых к работе устройств робота необходимые ему, вызывает соответствующие команды и передает управление следующим блокам по какой-либо исходящей ветке (которая определяется, опять-таки, самой реализацией блока). При этом не делается различий, является ли найденное устройство частью реального робота или симулируемым, таким образом, одна и та же подсистема интерпретации используется для исполнения диаграммы в двух из трех режимов (гл.~\ref{chapter:commonDescription}).

Если на каком-то шаге интерпретации повстречался блок распараллеливания, интерпретатор пополняет список запущенных потоков и запускает новые потоки исполнения с соответствующих точек, создавая для каждого свой стек вызовов. Если встретился вызов подпрограммы, вычисляются ее параметры, укладываются на текущий стек вызовов, и далее процесс интерпретации повторяется рекурсивно. При достижении любого завершающего блока со стека снимается верхний фрейм, и исполнение продолжается с соответствующей точки на предыдущей диаграмме. Если при снятии очередного фрейма стек вызовов стал пустым, текущий поток исполнения считается завершенным. Таким образом, программа исполняется по мере того, как она <<открывается>> интерпретатору.

Отличительной чертой такой реализации является тот факт, что все изменения, вносимые пользователем на диаграмму во время процесса интерпретации, <<подхватываются на лету>>. Это является удобным, например, в случае подбора коэффициентов пропорциональности какого-либо регулятора, реализованного в программе. При этом процесс исполнения не изменившихся кусков диаграммы оптимизирован: объекты-реализации блоков кэшируются в отдельную таблицу, то же происходит с абстрактными синтаксическими деревьями и информацией о выводе типов выражений на текстовом языке. Таким образом, если содержимое программы не меняется во время процесса интерпретации, повторная передача управления в ветки программы повлечет использование уже созданных сущностей. Валидация диаграммы также осуществляется <<на лету>>, в случае, если в диаграмме найдено некорректное место, пользователю отображается локализованное сообщение об ошибке. Последняя черта может рассматриваться как отрицательная, так как сообщение об ошибке появляется лишь в момент ее достижения в программе.

Интерпретатор потокового языка работает в два этапа. На первом, подготовительном этапе диаграмма проходит валидацию, создаются объекты-реализации элементарных блоков, преобразующие диаграмму в команды на устройствах роботов подобно тому, как это происходит в интерпретаторе языка, описанного в предыдущей главе. Объекты-реализации соединяются друг с другом посредством механизма сигналов и слотов инструментария Qt в соответствии с тем, как они соединены потоками данных на диаграмме; здесь оказался полезным паттерн проектирования <<издатель-подписчик>>. На втором этапе интерпретатор запускает на автономное исполнение каждый из блоков, в который не входит ни один поток данных, каждый из которых, в свою очередь, будет активировать блоки, соединенные с ним выходными потоками данных при выработке токенов. Исполнение блоков происходит псевдопараллельно с централизованной очередью сообщений (рис.~\ref{image:dsPseudoparallelism}). Это решение отличает данный язык от всех его промышленных аналогов (к примеру, в Microsoft Robotics Developer Studio диаграмма разворачивается в набор независимых веб-сервисов~\cite{jackson2007microsoft}), его причины состоят в узкой направленности языка на <<слабые>> контроллеры учебных роботов, в которых параллельное исполнение большого количества блоков затруднительно или вовсе невозможно. Тем не менее, в языке все же присутствует блок распараллеливания, который полезен, например, для выражения вышеупомянутых подходов к проектированию сложных систем управления. Такой блок может рассматриваться как механизм низкоуровневого управления вычислительными ресурсами в языке.

\begin{figure}[ht]
    \centering
    \includegraphics[width=4.5in]{DF_Interpretation_Process.png}
    \caption{Механизм исполнения потоковой программы в TRIK Studio}
    \label{image:dsPseudoparallelism}
\end{figure}

\section{Генераторы}
\label{chapter:generators}

Одна из наиболее важных и востребованных функций среды TRIK Studio --- генерация читаемого кода по визуальной диаграмме. По одной и той же диаграмме может быть сгенерирован код на любом поддерживаемом средой текстовом языке (C, JavaScript, F\#, Pascal, РуСи~\cite{тереховотечественные}, байткод ВМ EV3). Под визуальными диаграммами в данном разделе будем подразумевать программы на языке для начинающих (с передачей управления), под генераторами --- модули генерации кода по визуальным диаграммам именно этого языка. Общие принципы построения системы генераторов для потокового языка похожи на изложенные и здесь обсуждаться не будут.

Визуальная диаграмма состоит из блоков и стрелок, таким образом, описывает \textit{граф потока управления} программы~\cite{steven1997advanced}. Все основные алгоритмические конструкции (развилки, циклы, конструкции выбора и т.д.) складываются из стрелок. Например, чтобы задать бесконечный цикл, достаточно лишь провести стрелку от блока к одному из предыдущих, для описания циклов вида \texttt{while-do}, \texttt{do-while} или с инструкцией \texttt{break} внутри тела достаточно лишь провести одну из веток развилки из тела цикла к соответствующему блоку вне его. Очевидно, что одна стрелка на диаграмме соответствует инструкции \texttt{goto} в коде. Однако код, содержащий инструкции \texttt{goto} весьма труден для чтения человеком, тем более не подходит для обучения азам текстового программирования, поэтому следует избегать их появления в сгенерированном коде. Тем не менее, на TRIK Studio возможно написать программу, не выразимую общепринятыми алгоритмическими конструкциями, в таком случае появления инструкций \texttt{goto} в коде не избежать. С другой стороны, далеко не все современные текстовые языки поддерживают инструкцию \texttt{goto} (например, в языке JavaScript такой поддержки нет). Будем называть \textit{структурированными} диаграммы, которые можно выразить стандартными алгоритмическими блоками (\texttt{if-then}, \texttt{if-then-else}, \texttt{while-do loop}, \texttt{do-while loop}, \texttt{while-break loop}, \texttt{switch}), код на текстовом языке, соответствующий структурированной диаграмме также будем называть \textit{структурированным}. В противном случае будем говорить, что диаграмма \textit{неприводима}, а код будем называть \textit{неструктурированным}. В случае, если диаграмму не удается сгенерировать в структурированный код, пользователю должно быть показано предупреждение. Возможность генерации в неструктурированный код должна быть, так как требуется запускать на автономное исполнение даже запутанные диаграммы.

Таким образом, реализация системы генераторов в TRIK Studio потребовала решения двух нетривиальных задач, которые сформулированы ниже в виде требований.

\begin{itemize}
    \item Система генераторов должна быть организована таким образом, чтобы на добавление в систему генератора в новый текстовый язык занимало минимальное количество времени и сил. По возможности, это должно быть по силам даже людям, не знакомым с кодом системы.
    \item Для каждого языка (где это возможно) система должна поддерживать два режима генерации: структурированные диаграммы должны быть сгенерированы в структурированный код, запутанные --- в неструктурированный. При этом успешность структурирования диаграммы не должна зависеть от ее размера и сложности.
\end{itemize}

Первая задача является чисто архитектурной. Ее решение представлено на рисунке~\ref{image:generatorsArchitecture}. Основная идея --- разделение процесса генерации на два этапа. На первом диаграмма преобразуется в представление, независимое от целевого языка генерации --- \textit{семантическое дерево}. Семантическое дерево упорядочивает структуру графа потока управления до <<древесной>>, в независимости от того, является ли диаграмма структурированной или нет. В случае, если диаграмма структурирована, родительский узел семантического дерева всегда соответствует блоку вычислений в целевом коде, дети --- инструкциям этого блока, среди которых нет \texttt{goto}. Опишем последовательность действий, отображенных на рисунке~\ref{image:generatorsArchitecture}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=4.5in]{TS_Generators_Architecture.png}
    \caption{Архитектура подсистемы генерации кода в TRIK Studio}
    \label{image:generatorsArchitecture}
\end{figure}

На вход генератору поступает визуальная диаграмма. На первом этапе диаграмма обходится в глубину компонентой-валидатором (построенной с применением шаблона проектирования <<посетитель>>). Для всех выражений на встроенном текстовом языке в свойствах блоков происходит их синтаксический разбор и вывод типов. В случае, если диаграмма или код в свойстве содержит ошибки, о них сообщается пользователю в локализованном виде и процесс завершается. В случае, если диаграмма синтаксически корректна, она поступает на вход анализатору потока управления, о котором будет рассказано абзацем ниже. В зависимости от того, может ли диаграмма быть сгенерирована в структурированный код, выбирается промежуточный генератор независимого представления, который извлекает семантическое дерева из потока управления диаграммы. Если целевой язык не поддерживает инструкцию \texttt{goto} или, наоборот, высокоуровневые конструкции, как, например, ассемблер-подобный байткод ВМ EV3 (что указывается в конфигурации генератора), соответствующему генератору будет предпочтена его альтернатива. Наконец, на последнем шаге процесса генерации семантическое дерево печатается в целевой текстовый язык. Для этого используется подход с заданием шаблонов генерации для целевого текстового языка. Все, чтобы необходимо сделать для реализации нового генератора --- переопределить набор этих шаблонов и указать конфигурацию генератора. К примеру, шаблон генерации условного оператора в язык C выглядит следующим образом:

\begin{figure*}[ht]
\begin{verbatim}
    if (@@CONDITION@@) {
        @@THEN_BODY@@
    } else {
        @@ELSE_BODY@@
    }
\end{verbatim}
\end{figure*}

Вторая из решенных проблем --- реализация модуль анализатора потока управления. В терминах текстовых языков задача звучит так: по данной программе, поток управления которой описан исключительно инструкциями \texttt{goto} требуется выдать эквивалентную структурированную программу. Данная задача решалась различными исследователями, работающими в области декомпиляции программного кода~\cite{steven1997advanced,деревенец2009структурный}. Приемлемый способ ее решения по методу \textit{интервального анализа} графа потока управления описан, к примеру, в монографии~\cite{steven1997advanced}. Алгоритм интервального анализа графа потока управления диаграммы с незначительными модификациями реализован в TRIK Studio. Коротко опишем его.

Неформально говоря, \textit{интервал} --- это участок графа потока управления с одним входом и одним выходом. Целью алгоритма является построение дерева вложенности интервалов графа потока управления программы, которое в нашем случае и является семантическим деревом. Алгоритм работает на рекурсивном подъеме поиска в глубину в графе потока управления. На каждом шагу алгоритм пробует сопоставить подграф, выходящий из текущей вершины с каждым из шаблонов элементарных интервалов (алгоритмических конструкций, в терминах которых и будет структурирована программа). Если такой шаблон удается найти, весь подграф сворачивается в одну вершину и процесс продолжается. Самый простой пример такого шаблона --- два интервала, соединенные ровно одной дугой, что соответствует последовательной композиции операторов. Если шаблона интервала не нашлось, то диаграмма считается неприводимой.

Очевидными ограничениями на целевой языка в текущей реализации является его императивность: цепочка блоков на диаграмме должна преобразовываться в последовательное исполнение утверждений в текстовом языке, что проще всего достигается применением оператора последовательной композиции. Тем не менее,  идея подхода с независимым представлением диаграммы в виде может помочь даже здесь. К примеру, для поддержки генерации в чисто функциональные языки достаточно расширить элементы независимого представления конструкцией продолжения (continuation passing style, CPS) и добавить промежуточный генератор диаграммы в независимое представление в форме CPS. После этого достаточно переопределить шаблоны печати независимого представления во все необходимые языки.

\section{Двумерное имитационное моделирование}
\label{chapter:2dModel}

Особая часть среды TRIK Studio, отделимая от всей остальной системы --- подсистема двумерного имитационного моделирования робота (двумерный симулятор). Окно симулятора встроено в интерфейс TRIK Studio, но может и использоваться отдельно. Основная часть симулятора --- редактор модели мира. В специальном меню можно выбрать инструмент рисования (подобно тому, как это происходит в большинстве графических редакторов). Инструменты рисования делятся на стены (твердые предметы, на которые реагируют ультразвуковые и инфракрасные датчики роботов и сквозь которые робот не может проехать) и цветные маркеры на полу (элементы, на которые реагируют датчики цвета, освещенности и эмуляторы систем видео-зрения) --- прямые линии и кубические кривые безье, прямоугольники, эллипсы и стилус (произвольная растровая фигура, рисующаяся мышью как карандашом). Для каждого маркера на полу может быть задана его толщина, цвет и заливка. Модель робота всегда присутствует на сцене редактора мира, на нем произвольным образом можно размещать в виртуальные датчики. Робот представляет собой двухколесную тележку с дифференциальным приводом. Для удобства регионы сканирования датчиков расстояния подсвечиваются. На отдельной панели для каждой поддерживаемой модели робота (NXT, EV3 или TRIK) присутствует эмулятор панели контроллера: фронтальное изображение его лицевой панели с кнопками, нажатие мышью на которые эмулирует нажатие на кнопку реального контроллера, цветными светодиодами, меняющими свой цвет соответственно тому, как того требует написанная пользователем программа и эмулятор дисплея, изображение на котором можно менять блоками из группы <<Рисование>>.

Важной особенностью симулятора является неотличимость процесса исполнения программы от процесса создания модели мира. Модель мира может редактироваться в произвольный момент, на любое добавление пользователем стенок и цветных элементов во время исполнения программы датчики начнут реагировать немедленно, положение и направление робота и его датчиков в пространстве может быть изменено в любой момент, что соответствует в реальном мире физическому воздействию на корпус робота.

Симулятор построен на основе архитектуры MVC. Модель содержит сериализуемое описание мира и робота, уведомляет о любом изменении любого свойства любого предмета. На события модели подписывается представление, таким образом, что все изменения автоматически отображаются на сцене и панелях симулятора. Пользовательские действия в представлении выполняются через контролирующую компоненту, которая кладет очередное действие на вершину специального стека для возможности их отмены и повтора (undo-redo). 

Важной частью модели является ее <<физика>>. В симуляторе реализовано две физические модели поведения робота: идеальная и реалистичная. В идеальной физике игнорируются силы трения о пол и стены, импульсы моторов, при неизменных скоростях моторов робот будет двигаться равномерно, (без ускорения и замедления). Любое, даже самое легкое столкновение со стеной в такой модели остановит робота. В реалистичной модели ведется полный учет сил тяги и трения колес робота о пол и стены, при столкновении со стеной робот поведет себя сходно с тем, как это происходит в реальности. Описание физики такого поведения является скорее материалом для отдельной статьи и здесь приведено не будет. Переключение между физическими моделями происходит при выставлении пользователем флажка <<реалистичная физика>> и также может произойти в любой момент, даже во время исполнения программы. Также пользователь в любой момент может добавить гауссов шум к показаниям датчиков и значениям импульсов на моторах.

Время в двумерном симуляторе не соответствует процессорному: в нем существует централизованная временная прямая, темп хода которой может меняться на специальной панели. Система построена таким образом, что поведение робота не зависит от темпа хода модельного времени. Та же самая временная прямая используется в интерпретаторах визуальных языков TRIK Studio для соответствия блоков работы со временем модельному, а не процессорному времени.

\section{Язык проверки ограничений}
\label{chapter:constraintsChecker}

Последняя важная часть TRIK Studio, о которой будет рассказано в данной работе --- механизм автоматической проверки заданий на TRIK Studio. Модель мира в двумерном симуляторе может быть превращена специальными средствами среды в упражнение, распространяемое между учениками. Для этого достаточно задать два набора описаний:

\begin{itemize}
    \item описание того, какие части упражнения нельзя менять ученику (модель мира, начальное положение робота и его датчиков, сам набор датчиков, привязку моторов и физические настройки симуляции),
    \item программа проверки корректности решения задачи.
\end{itemize}

Программа проверки ограничений описывается на специальном текстовом XML-подобном языке. Данный язык интересен сам по себе и может рассматриваться как отдельный результат работы. Программа на таком языке представляет собой множество событий $\{ e_1, e_2, ..., e_n \}$, где каждое событие 
$e_i$ представляет собой это тройку $(id_i, c_i, T_i)$:

\begin{itemize}
    \item $id_i$ --- идентификатор события, внутренняя метка, по которой другие события могут получать информацию о событии $e_i$, может быть пустым;
    \item $c_i$ --- условие срабатывания события, представляющее собой формулу логики первого порядка без кванторов, об интерпретации предикатных и функциональных символах которой будет рассказано ниже;
    \item $T_i$ --- упорядоченный список элементарных триггеров $[ t_{i1}, t_{i2}, ..., t_{in} ]$. Элементарный триггер задает действие это некоторое 
            действие, выполняемое в момент истинности условия срабатывания события $c_i$.
\end{itemize}

Одно событие задается одним элементом в XML-спецификации программы. Каждое событие в текстовом описании 
программы может быть представлено либо в \textit{каноническом} виде, либо в виде \textit{ограничения}. Событие в канонической форме --- уже описанная тройка $(id_i, c_i, T_i)$.

Событие в форме ограничения --- это тройка $(id_j, c_j, message_j)$. Ограничение интерпретируется как событие $(id_i, !c_i, [ fail(message_j) ])$, где <<!>> означает логическое отрицание, а $fail(message_j)$ --- триггер прекращения исполнения имитационной модели с выдачей сообщения об ошибке $message_j$. Другими словами, ограничение --- это событие, которое срабатывает тогда, когда нарушается заданное условие, и которое сообщает пользователю об этом нарушении. Особый случай такого ограничения --- лимит времени на выполнение программы. Такое ограничение должно присутствовать в любой программе проверки ограничений имитационной модели TRIK Studio, так как проверка, очевидно, не может осуществляться бесконечное время. Наличие ограничения на лимит времени проверяется как часть синтаксиса языка. Описание события в форме ограничения введено в язык из чисто прагматических соображений, так как на практике удобно описывать утверждения вида <<робот $x$ не должен покидать пределы зоны $z$>> или <<к роботу $x$ должен быть подключен набор датчиков $s$>> именно в терминах ограничений, а не событий.

Коротко опишем множество используемых в языке предикатных и функциональных символов и элементарных триггеров. Предикатные символы можно поделить на несколько групп:
\begin{itemize}
    \item Предикаты сравнения значений термов $>$, $<$, $\leq$, $\geq$, $=$, $\neq$.
    \item Пространственные предикаты. Имеют вид <<предмет $x$ находится внутри области $y$>>.
    \item Предикаты состояния событий $settedUp(id_i)$ и $dropped(id_i)$, описывающие состояние события 
            (активно/неактивно). В активном состоянии событие может быть выполнено, в неактивном оно не выполнет триггеры даже при выполнении условия срабатывания события.
    \item Предикат времени $timer(t)$, который становится истинным спустя $t$ отсчетов модельного времени и остается истинным после, а до этого момента ложен.
    \item Прочие предикаты, выражаемые уже описанными и введенные исключительно в целях удобства.
\end{itemize}

Функциональные символы бывают следующих видов:
\begin{itemize}
    \item Константы различных типов (целочисленные, с плавающей точкой, строковые, логические, цветовые, геометрические и пр.).
    \item Символ $variableValue(id)$ для получения значения переменной с идентификатором $id$. Переменные могут быть полезны для реализации сложной логики проверки, например, при подсчете числа проделанных роботом итераций.
    \item Арифметические и геометрические операции над значениями других термов, например, модуль числа, подсчет расстояния между двумя точками или выпуклая оболочка фиксированного множества точек.
    \item Символы сравнения формы двух объектов с использованием расстояния Левенштейна, полезные при проверке схожести фигур, нарисованных роботом.
    \item Символ $objectState(path)$ --- основное средство получения информации о состоянии устройств робота и свойствах предмета из внешнего мира. Аргумент $path$ --- путь к желаемому свойству в иерархии объектов в модели мира. Такой путь будет преобразован системой в последовательность получений значений свойств объектов C++, реализующих данные объекты в модели мира посредством механизма рефлексии Qt. Подробное описание всех свойств, предоставляемых окружением, довольно громоздкое и не будет здесь приведено.
\end{itemize}

Наконец, элементарные триггеры делятся на следующие категории:
\begin{itemize}
    \item $success$, $fail(message)$ --- управление состоянием проверки. Первый помечает результат проверки как успешный, второй --- как неудавшийся, отображая заданное сообщение об ошибке.
    \item Триггеры задания значения переменных и изменения значения свойств элементов имитационной модели мира.
    \item Триггеры управления состоянием событий. Каждое событие может активировать или деактивировать другое или себя; с помощью этого можно задавать сложную логику проверки.
\end{itemize}

Пример простейшей программы на языке задания ограничений имитационной модели мира в TRIK Studio приведён в листинге~\ref{code:constraints}.

\captionsetup[figure]{name=Листинг}
\setcounter{figure}{0}

\begin{figure*}[!t]
\begin{verbatim}
<!-- Корневой элемент, означающий начало программы проверки ограничений -->
<constraints>

    <!-- Обязательное в любой программе ограничение на время работы -->
    <timelimit value="2000"/>

    <!-- Ограничение на местоположение робота -->
    <constraint failMessage="Робот покинул допустимую область!">
        <inside objectId="robot1" regionId="myspace"/>
    </constraint>

    <!-- Условие успешности программы: робот должен сказать "Привет" с помощью
        встроенного механизма синтезирования речи и нарисовать улыбку на дисплее -->
    <event settedUpInitially="true">
        <conditions glue="and">
            <equals>
                <objectState object="robot1.shell.lastPhrase"/>
                <string value="Привет"/>
            </equals>
            <equals>
                <objectState object="robot1.display.smiles"/>
                <bool value="true"/>
            </equals>
        </conditions>
        <trigger>
            <success/>
        </trigger>
    </event>

</constraints>
\end{verbatim}
\caption{Пример программы проверки ограничений имитационной модели мира в TRIK Studio.}
\label{code:constraints}
\end{figure*}

Архитектурно система проверки ограничений представляет собой отдельно стоящий модуль, использующий в качестве разделяемых библиотек ядро и имитационную модель системы TRIK Studio. Использование рефлексию, реализованную для C++ в библиотеке Qt для доступа к свойствам объектов имитационной модели позволяет намного проще масштабировать саму модель: при расширении возможностей системы или добавлении нового симулируемых устройств новые объекты и свойства будут немедленно доступны из языка описания ограничений, без дополнительной модификации кода проверяющей системы. Тестовая система подписывается на события имитационной модели подобно тому, как это делает представление симулятора (в смысле архитектуры MVC), и вызывает проверку ограничений на каждом отсчете модельного времени. При этом проверяются только активные ограничения, которых в каждый конкретный момент времени немного, поэтому общая скорость работы симулятора при наличии проверяющей программы практически не меняется.

Описанный язык удобен для задания пространственных и временных ограничений на поведение системы. Он является значительно более удобным и выразительным, чем, к примеру, язык темпоральных логик или топологико-темпоральных логик, используемых для описания формальных ограничений на поведение робота в работах последних лет~\cite{mordvinov2016formal,kress2007s,бугайченко2007разработка,дмитриев2013адаптация}. При этом, язык не тьюринг-полон (на нем, к примеру, нельзя выразить нормальные алгоритмы маркова из-за отсутствия возможностей работы с коллекциями произвольной длины, что делает невозможным реализацию на нем замены в строке), это говорит о возможности автоматического анализа интересных свойств программ на нем. Ко всему прочему, подмножество этого языка может использоваться для описания требований к программе для последующей ее формальной верификации. В будущих версиях TRIK Studio планируется реализация визуального конструктора ограничений на этом языке. Появление такого конструктора и интеграция мощного верификатора даст возможность формально доказывать корректность визуальных программ, не написав ни одной формулы формальной логики. Подробное исследование этого вопроса --- тема для будущих работ.

Система проверки ограничений используется для функционального тестирования среды на сервере системы непрерывной интеграции. Об автоматизированном тестировании среды TRIK Studio подробнее рассказано в работе~\cite{mordvinov2016testing}.

\section*{Заключение}
\label{chapter:conclusion}

В статье было дано техническое описание среды программирования роботов TRIK Studio. Среда разработана на кафедре системного программирования Санкт-Петербургского Государственного Университета и по данным системы Google Analytics в настоящее время насчитывает около десятка тысяч пользователей на всех обитаемых континентах мира. На данный момент интерфейс среды переведен на три языка (русский, английский, французский), в том числе силами сообщества пользователей. Система активно развивается, исходный код среды находится в открытом доступе\footnote{https://github.com/qreal/qreal (дата обращения: 14.05.2016)}. Без учета ядра DSM-платформы, код системы содержит порядка 100 тысяч строк, включая техническую документацию всех компонентов, написанную в doxygen\footnote{http://www.doxygen.org/ (дата обращения: 14.05.2016)}-формате в заголовочных файлах среды.

Будущие направления работы разделяются на два больших класса: технические улучшения среды и исследовательские проекты. Задачи из первого класса появляются из общения с педагогами и учениками, пользующимися средой, и характеризуются большой численностью (на системе управления процессом разработки их записано порядка сотен). К примеру, это задачи по поддержке новых робототехнических платформ в среде (таких, как, Arduino), улучшение двумерного симулятора (доработка физической модели, поддержка симуляции мультиагентных систем и т.д.), поддержка новых текстовых языков, общие улучшения ядра DSM-платформы QReal и т.д. Задачи из второго класса требуют применение большого количества теоретических научных работ в области компьютерных наук. На данный момент исследовательская работа идет по двум <<ветвям>>: ветви предметно-ориентированного визуального моделирования и ветви формальных методов анализа программных систем. К первой ветви относится, к примеру, работа по автоматической генерации метамодели потокового языка из описания доступных пакетов системы промежуточного уровня на роботе (такой, как ROS~\cite{quigley2009ros}). В рамках второго направления ведутся работы по выражению строгой семантики языков с целью применения подходов к формальной верификации диаграмм.

\pagebreak

\bibliographystyle{utf8gost705u}
\bibliography{TRIKStudioTechnicalIntroduction}

\end{document}
